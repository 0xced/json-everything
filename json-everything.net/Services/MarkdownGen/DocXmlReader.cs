using System.Reflection;
using System.Xml;
using System.Xml.XPath;

namespace JsonEverythingNet.Services.MarkdownGen;

/// <summary>
///     Helper class that reads XML documentation generated by C# compiler from code comments.
/// </summary>
public class DocXmlReader
{
	private readonly HttpClient _client;

	/// <summary>
	///     Dictionary of XML navigators for multiple assemblies.
	/// </summary>
	private readonly Dictionary<Assembly, XPathNavigator?> _assemblyNavigators;

	/// <summary>
	///     Function that returns path to XML documentation file for specified assembly.
	/// </summary>
	private readonly Func<Assembly, string?> _assemblyXmlPathFunction;

	/// <summary>
	///     Default value is true.
	///     When it is set to true DocXmlReader removes leading spaces and an empty
	///     lines at the end of the comment.
	///     By default XML comments are indented for human readability but it adds
	///     leading spaces that are not present in source code.
	///     For example here is compiler generated XML documentation with '-'
	///     showing spaces for readability.
	///     ----
	///     <summary>
	///         ----Text
	///         ----
	///     </summary>
	///     With UnIndentText set to true returned summary text is just "Text"
	///     With UnIndentText set to false returned summary text contains leading spaces
	///     and the trailing empty line "\n----Text\n----"
	/// </summary>
	private readonly bool _unIndentText;

	/// <summary>
	///     Open XML documentation files based on assemblies of types. Comment file names
	///     are generated based on assembly names by replacing assembly location with .xml.
	/// </summary>
	/// <param name="assemblyXmlPathFunction">
	///     Function that returns path to the assembly XML comment file.
	///     If function is null then comments file is assumed to have the same file name as assembly.
	///     If function returns null or if comments file does not exist then all comments for types from that
	///     assembly would remain empty.
	/// </param>
	/// <param name="client"></param>
	public DocXmlReader(Func<Assembly, string?> assemblyXmlPathFunction, HttpClient client)
	{
		_assemblyNavigators = new Dictionary<Assembly, XPathNavigator?>();
		_unIndentText = true;
		_assemblyXmlPathFunction = assemblyXmlPathFunction;
		_client = client;
	}

	#region Public methods

	/// <summary>
	///     Returns comments for the method or constructor. Returns empty comments object
	///     if comments for method are missing in XML documentation file.
	///     Returned comments tags:
	///     Summary, Remarks, Parameters (if present), Responses (if present), Returns
	/// </summary>
	/// <returns></returns>
	private async Task<MethodComments?> GetMethodComments(MethodBase methodInfo)
	{
		return await GetMethodComments(methodInfo, false);
	}

	/// <summary>
	///     Returns comments for the class method. May return null object is comments for method
	///     are missing in XML documentation file.
	///     Returned comments tags:
	///     Summary, Remarks, Parameters (if present), Responses (if present), Returns
	/// </summary>
	/// <param name="methodInfo"></param>
	/// <param name="nullIfNoComment">Return null if comment for method is not available</param>
	/// <returns></returns>
	public async Task<MethodComments?> GetMethodComments(MethodBase methodInfo, bool nullIfNoComment)
	{
		var methodNode = await GetXmlMemberNode(methodInfo.MethodId(), methodInfo.ReflectedType);
		if (nullIfNoComment && methodNode == null) return null;
		var comments = new MethodComments();
		return await GetComments(methodInfo, comments, methodNode);
	}

	private async Task<MethodComments?> GetComments(MethodBase methodInfo, MethodComments comments, XPathNavigator? node)
	{
		if (node == null) return comments;

		GetCommonComments(comments, node);
		comments.Parameters = GetParametersComments(node);
		comments.TypeParameters = GetNamedComments(node, _typeParamXPath, _nameAttribute);
		comments.Returns = GetReturnsComment(node);
		comments.Responses = GetNamedComments(node, _responsesXPath, _codeAttribute);
		comments = await ResolveInheritdocComments(comments, methodInfo);
		return comments;
	}

	/// <summary>
	///     Return Summary comments for specified type.
	///     For Delegate types Parameters field may be returned as well.
	/// </summary>
	/// <param name="type"></param>
	/// <returns>TypeComment</returns>
	public async Task<TypeComments> GetTypeComments(Type type)
	{
		var comments = new TypeComments();
		var node = await GetXmlMemberNode(type.TypeId(), type);
		return await GetComments(type, comments, node);
	}

	private async Task<TypeComments> GetComments(Type type, TypeComments comments, XPathNavigator? node)
	{
		if (node == null) return comments;
		if (type.IsSubclassOf(typeof(Delegate))) comments.Parameters = GetParametersComments(node);
		GetCommonComments(comments, node);
		comments = await ResolveInheritdocComments(comments, type);
		return comments;
	}

	/// <summary>
	///     Returns comments for specified class member.
	/// </summary>
	/// <param name="memberInfo"></param>
	/// <returns></returns>
	public async Task<CommonComments> GetMemberComments(MemberInfo memberInfo)
	{
		var comments = new CommonComments();
		var node = await GetXmlMemberNode(memberInfo.MemberId(), memberInfo.ReflectedType);
		return await GetComments(memberInfo, comments, node);
	}

	private async Task<CommonComments> GetComments(MemberInfo memberInfo, CommonComments comments, XPathNavigator? node)
	{
		if (node == null) return comments;

		GetCommonComments(comments, node);
		comments = await ResolveInheritdocComments(comments, memberInfo);
		return comments;
	}

	/// <summary>
	///     Get enum type description and comments for enum values. If <paramref name="fillValues" />
	///     is false and no comments exist for any value then ValueComments list is empty.
	/// </summary>
	/// <param name="enumType">
	///     Enum type to get comments for. If this is not an enum type then functions throws an
	///     ArgumentException
	/// </param>
	/// <param name="fillValues">
	///     True if ValueComments list should be filled even if
	///     none of the enum values have any summary comments
	/// </param>
	/// <returns>EnumComment</returns>
	public async Task<EnumComments> GetEnumComments(Type enumType, bool fillValues = false)
	{
		if (!enumType.IsEnum) throw new ArgumentException(nameof(enumType));

		var comments = new EnumComments();
		var typeNode = await GetXmlMemberNode(enumType.TypeId(), enumType);
		if (typeNode != null) GetCommonComments(comments, typeNode);

		var valueCommentsExist = false;
		foreach (var enumName in enumType.GetEnumNames())
		{
			var valueNode = await GetXmlMemberNode(enumType.EnumValueId(enumName), enumType);
			valueCommentsExist |= valueNode != null;
			var valueComment = new EnumValueComment(enumName, (int)Enum.Parse(enumType, enumName));
			comments.ValueComments.Add(valueComment);
			GetCommonComments(valueComment, valueNode);
		}

		if (!valueCommentsExist && !fillValues) comments.ValueComments.Clear();
		return comments;
	}

	#endregion

	#region XML items and atribute names

	// XPath strings and XML attribute names
	private const string _memberXPath = "/doc/members/member[@name='{0}']";
	private const string _summaryXPath = "summary";
	private const string _remarksXPath = "remarks";
	private const string _exampleXPath = "example";
	private const string _paramXPath = "param";
	private const string _typeParamXPath = "typeparam";
	private const string _responsesXPath = "response";
	private const string _returnsXPath = "returns";
	public const string InheritdocXPath = "inheritdoc";

	//  XML attribute names
	private const string _nameAttribute = "name";
	private const string _codeAttribute = "code";
	private const string _crefAttribute = "cref";

	#endregion

	#region XML helper functions

	private void GetCommonComments(CommonComments comments, XPathNavigator? rootNode)
	{
		comments.Summary = GetSummaryComment(rootNode);
		comments.Remarks = GetRemarksComment(rootNode);
		comments.Example = GetExampleComment(rootNode);
		comments.Inheritdoc = GetInheritdocTag(rootNode);
	}

	private async Task<XPathNavigator?> GetXmlMemberNode(string name, Type? typeForAssembly, bool searchAllCurrentFiles = false)
	{
		var node = await GetXmlMemberNodeFromDictionary(name, typeForAssembly);
		if (node != null ||
		    !searchAllCurrentFiles ||
		    _assemblyNavigators.Count <= 1 && typeForAssembly != null) return node;
		foreach (var docNavigator in _assemblyNavigators.Values)
		{
			node = docNavigator?.SelectSingleNode(string.Format(_memberXPath, name));
			if (node != null) break;
		}

		return node;
	}

	private async Task<XPathNavigator?> GetXmlMemberNodeFromDictionary(string name, Type? typeForAssembly)
	{
		var typeNavigator = await GetNavigatorForAssembly(typeForAssembly?.Assembly);
		return typeNavigator?.SelectSingleNode(string.Format(_memberXPath, name));
	}

	private async Task<XPathNavigator?> GetNavigatorForAssembly(Assembly? assembly)
	{
		if (assembly == null) return null;
		if (_assemblyNavigators.TryGetValue(assembly, out var typeNavigator)) return typeNavigator;

		var commentFileName = _assemblyXmlPathFunction(assembly);
		if (commentFileName == null)
		{
			_assemblyNavigators.Add(assembly, null);
			return null;
		}

		var response = await _client.GetStringAsync(commentFileName);
		var document = new XmlDocument();
		document.LoadXml(response);
		var docNavigator = document.CreateNavigator();
		if (docNavigator == null) return null;

		_assemblyNavigators.Add(assembly, docNavigator);
		return docNavigator;
	}

	private string GetXmlText(XPathNavigator? node)
	{
		var innerText = node?.InnerXml ?? "";
		if (!_unIndentText || string.IsNullOrEmpty(innerText)) return innerText;

		var outerText = node?.OuterXml ?? "";
		var indentText = FindIndent(outerText);
		if (string.IsNullOrEmpty(indentText)) return innerText;
		return innerText.Replace(indentText, indentText[0].ToString()).Trim('\r', '\n');
	}

	private static string FindIndent(string? outerText)
	{
		if (string.IsNullOrEmpty(outerText)) return "";
		var end = outerText.LastIndexOf("</", StringComparison.Ordinal);
		if (end < 0) return "";
		var start = end - 1;
		// ReSharper disable once EmptyEmbeddedStatement
		for (; start >= 0 && outerText[start] != '\r' && outerText[start] != '\n'; start--) ;
		if (start < 0 || end <= start) return "";
		return outerText.Substring(start, end - start);
	}


	private string GetSummaryComment(XPathNavigator? rootNode)
	{
		return GetXmlText(rootNode?.SelectSingleNode(_summaryXPath));
	}

	private string GetRemarksComment(XPathNavigator? rootNode)
	{
		return GetXmlText(rootNode?.SelectSingleNode(_remarksXPath));
	}

	private string GetExampleComment(XPathNavigator? rootNode)
	{
		return GetXmlText(rootNode?.SelectSingleNode(_exampleXPath));
	}

	private string GetReturnsComment(XPathNavigator? methodNode)
	{
		var responseNodes = methodNode?.Select(_returnsXPath);
		if (responseNodes?.MoveNext() == true)
			return GetXmlText(responseNodes.Current);
		return "";
	}

	private List<(string Name, string Text)> GetParametersComments(XPathNavigator rootNode)
	{
		return GetNamedComments(rootNode, _paramXPath, _nameAttribute);
	}

	private List<(string Name, string Text)> GetNamedComments(XPathNavigator rootNode, string path, string attributeName)
	{
		var list = new List<(string Name, string Text)>();
		var childNodes = rootNode.Select(path);

		while (childNodes.MoveNext())
		{
			var code = childNodes.Current?.GetAttribute(attributeName, "");
			if (code == null) continue;
			list.Add((code, GetXmlText(childNodes.Current)));
		}

		return list;
	}

	private InheritdocTag? GetInheritdocTag(XPathNavigator? rootNode)
	{
		if (rootNode == null) return null;
		var inheritdoc = GetNamedComments(rootNode, InheritdocXPath, _crefAttribute);
		if (inheritdoc.Count == 0) return null;
		return new InheritdocTag(inheritdoc.First().Item1);
	}

	private static bool NeedsResolving(CommonComments? comments)
	{
		return comments?.Inheritdoc != null &&
		       string.IsNullOrEmpty(comments.Summary) &&
		       string.IsNullOrEmpty(comments.Remarks) &&
		       string.IsNullOrEmpty(comments.Example);
	}

	private async Task<bool> GetCrefComments(string? cref, Type? typeForAssembly, CommonComments comments,
		Func<XPathNavigator?, Task> getCommentAction)
	{
		if (string.IsNullOrEmpty(cref)) return false;
		var typeNode = await GetXmlMemberNode(cref, typeForAssembly, true);
		var inheritdoc = comments.Inheritdoc;
		comments.Inheritdoc = null;
		await getCommentAction(typeNode);
		comments.Inheritdoc = inheritdoc;
		return true;
	}

	private async Task<MethodComments> ResolveInheritdocComments(MethodComments comments, MethodBase methodInfo)
	{
		if (!NeedsResolving(comments) ||
		    comments.Parameters.Count > 0 ||
		    !string.IsNullOrEmpty(comments.Returns) ||
		    comments.Responses.Count > 0 ||
		    comments.TypeParameters.Count > 0) return comments;

		// If an explicit cref attribute is specified, the documentation from 
		// the specified namespace/type/member is inherited.
		if (await GetCrefComments(comments.Inheritdoc?.Cref, methodInfo.ReflectedType, comments,
			    async node => await GetComments(methodInfo, comments, node))) return comments;

		// For constructors:
		// - Search backwards up the type inheritance chain for a constructor 
		//   with a matching signature.
		// - If a match is found, its documentation is inherited.
		if (methodInfo.IsConstructor)
		{
			var baseClass = methodInfo.ReflectedType?.BaseType;
			var constructorSignature = methodInfo.GetParameters()
				.Select(p => p.ParameterType).ToArray();
			while (baseClass != null)
			{
				var baseConstructor = baseClass.GetConstructor(
					BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,
					null, CallingConventions.Any, constructorSignature, null);
				if (baseConstructor != null)
				{
					var newComments = await GetMethodComments(baseConstructor);
					if (newComments == null) return comments;
					newComments.Inheritdoc = comments.Inheritdoc;
					return newComments;
				}

				baseClass = baseClass.BaseType;
			}

			return comments;
		}

		// For virtual members and interface implementations:
		// - If the member is an override, documentation is inherited from the 
		//   member it overrides.
		// - If the member is part of an interface, documentation is inherited 
		//   from the interface member being implemented.
		var interfaceDeclaration = methodInfo.ReflectedType?
			.GetTypeInfo()
			.ImplementedInterfaces
			.Select(ii => methodInfo.ReflectedType.GetInterfaceMap(ii))
			.SelectMany(map => Enumerable.Range(0, map.TargetMethods.Length)
				.Where(n => map.TargetMethods[n] == methodInfo)
				.Select(n => map.InterfaceMethods[n]))
			.FirstOrDefault();
		if (interfaceDeclaration != null)
		{
			var newComments = await GetMethodComments(interfaceDeclaration);
			if (newComments == null) return comments;
			newComments.Inheritdoc = comments.Inheritdoc;
			return newComments;
		}

		if (methodInfo.IsVirtual)
		{
			var baseMethod = (methodInfo as MethodInfo)?.GetBaseDefinition();
			if (baseMethod != null)
			{
				var newComments = await GetMethodComments(baseMethod);
				if (newComments == null) return comments;
				newComments.Inheritdoc = comments.Inheritdoc;
				return newComments;
			}

			return comments;
		}


		return comments;
	}

	private async Task<TypeComments> ResolveInheritdocComments(TypeComments comments, Type type)
	{
		if (!NeedsResolving(comments) ||
		    comments.Parameters.Count > 0) return comments;

		// If an explicit cref attribute is specified, the documentation from
		// the specified namespace/type/member is inherited. 
		if (await GetCrefComments(comments.Inheritdoc?.Cref, type, comments,
			    async node => await GetComments(type, comments, node))) return comments;

		// For types and interfaces:
		// - Inherit documentation from all base classes working backwards up 
		//   the inheritance chain.
		// - Inherit documentation from all interface implementations (if any) 
		//   working through them in the order listed in the reflection information file (usually alphabetically).
		if (type.BaseType != null && type.BaseType != typeof(object))
		{
			var newComments = await GetTypeComments(type.BaseType);
			newComments.Parameters = comments.Parameters;
			newComments.Inheritdoc = comments.Inheritdoc;
			return newComments;
		}

		var interfaces = type.GetInterfaces();
		if (interfaces.Length > 0)
			foreach (var intf in interfaces.OrderBy(i => i.FullName))
			{
				var newComments = await GetTypeComments(intf);
				newComments.Parameters = comments.Parameters;
				newComments.Inheritdoc = comments.Inheritdoc;
				return newComments;
			}

		return comments;
	}

	private async Task<CommonComments> ResolveInheritdocComments(CommonComments comments, MemberInfo memberInfo)
	{
		if (!NeedsResolving(comments)) return comments;
		// If an explicit cref attribute is specified, the documentation from 
		// the specified namespace/type/member is inherited. 
		await GetCrefComments(comments.Inheritdoc?.Cref, memberInfo.DeclaringType, comments,
			async node => await GetComments(memberInfo, comments, node));
		return comments;
	}

	#endregion
}